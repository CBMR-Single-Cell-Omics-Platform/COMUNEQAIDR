#' Prepare folder structure for COMUNEQAID
#'
#' @param qc_path string, path to where qc output should go
#' @param bcl_folders vector of strings, bcl folders
#' @param comuneqaid_id string, comuneqaid run ID
#' @param bcl_path string, path to bcl input folder
#' @param fastq_path string, path to bcl output folder
#' @param out_path string, path to results output folder
#' @param log_path string, path to logs output folder
#' @param config_path string, path to config file output folder
#'
#' @return invisibly returns NULL
#' @export
prepare_folders <- function(qc_path, bcl_path, bcl_folders, comuneqaid_id,
                            fastq_path, out_path, log_path, config_path) {
  for (bcl in bcl_folders) {
    bcl_folder_path <- here::here(bcl_path, bcl)
    if (!dir.exists(bcl_folder_path)) {
      stop(bcl_folder_path, " does not exist.")
    }

    dir.create(
      path = here::here(fastq_path, basename(bcl)),
      showWarnings = FALSE,
      recursive = TRUE
    )
  }

  dir.create(here::here(qc_path, comuneqaid_id),
    showWarnings = FALSE,
    recursive = TRUE
  )
  dir.create(here::here(out_path, comuneqaid_id),
    showWarnings = FALSE,
    recursive = TRUE
  )
  dir.create(here::here(log_path, comuneqaid_id),
    showWarnings = FALSE,
    recursive = TRUE
  )
  dir.create(here::here(config_path),
             showWarnings = FALSE,
             recursive = TRUE
  )
  invisible(NULL)
}

#' Create pool table
#'
#' @param sheet data.frame generated by \link{read_input_files}
#' @param split_by character vector of column names to split the sheet by
#'
#' @return data.frame containing information about the 10x pools
#' @export
make_pool_table <- function(sheet, split_by = c("i7_index", "lane")) {
  # Split by the supplied columns, with than one unique level
  idx_split <- lapply(split_by, \(x) sheet[[x]])
  idx_split <- Filter(f = \(x) length(unique(x)) > 1L, idx_split)

  make_row <- function(x) {
    # hto_bcls may be missing and needs to be treated differently.
    # paste(NA) returns "NA" not NA
    hto_bcl <- unique(x[["hto_bcl"]])
    hto_bcl <- ifelse(is.na(hto_bcl), NA, paste(hto_bcl, sep = ";"))
    out <- list(
      i7_index = unique(x[["i7_index"]]),
      hash_index = unique(x[["hash_index"]]),
      lane = unique(x[["lane"]]),
      loaded_cells = sum(x[["loaded_cells"]]),
      `10x_bcl` = paste(unique(x[["10x_bcl"]]), collapse = ";"),
      hto_bcl = hto_bcl
    )
    out <- Filter(length, out)
    as.data.frame(out)
  }

  sheet_parts <- split(sheet, idx_split)

  pool_table <- lapply(sheet_parts, make_row)
  pool_table <- do.call("rbind", pool_table)

  # Without HTOs some columns contain only NA
  pool_table <- Filter(\(x) !all(is.na(x)), pool_table)

  if (!all(pool_table[["lane"]] == "*")) {
    pool_table[, "i7"] <- paste0(pool_table[, "i7"], "_L", pool_table[, "lane"])
  }

  colnames(pool_table) <- c(
    "i7_index" = "Index (10x)",
    "hash_index" = "Index (HTO)",
    "lane" = "Lane",
    "loaded_cells" = "Loaded Cells",
    "X10x_bcl" = "BCL PIN (10x)",
    "hto_bcl" = "BCL PIN (HTO)"
  )[colnames(pool_table)]

  pool_table
}

#' Infer chemistry for sequencing run
#'
#' @param bcl_folder path to bcl input folder
#'
#' @return string, version of chemistry used
#' @export
detect_chemistry <- function(bcl_folder) {
  run_param <- xml2::read_xml(file.path(bcl_folder, "RunParameters.xml"))
  idx2_cycles <- xml2::xml_find_all(run_param, "IndexRead2NumberOfCycles")
  idx2_cycles <- xml2::xml_contents(idx2_cycles)
  idx2_cycles <- xml2::xml_double(idx2_cycles)
  if (idx2_cycles == 10L) {
    out <- "RNA v3.1"
  } else if (idx2_cycles == 0L) {
    out <- "RNA v3.0"
  } else {
    stop(
      "Number of index 2 sequencing cycles does not match v3.1 or v3.0",
      " chemistry."
    )
  }
  out
}

#' Infer BCL folder from PIN
#'
#' @param sheet data.frame generated by \link{read_input_files}
#' @param bcl_path path to bcl input folder
#'
#' @return the data frame in 'sheet' where 10x_pin and hto_pin has been replaced
#' with 10x_bcl and hto_bcl
#' @export
from_pin_to_bcl <- function(sheet, bcl_path) {
  make_regex <- function(x) {
    paste0(
      "^([[:digit:]]{6})_[[:alpha:]]+[[:digit:]]+_",
      "0{",
      4L - nchar(x),
      "}",
      x,
      "_[[:alnum:]]+$"
    )
  }

  folder_10x <- lapply(make_regex(sheet[["10x_pin"]]),
    list.files,
    path = bcl_path
  )
  folder_10x <- unlist(folder_10x)

  folder_hto <- lapply(make_regex(sheet[["hto_pin"]]),
    list.files,
    path = bcl_path
  )
  folder_hto <- unlist(folder_hto)

  # I theory there could be multiple runs with the same pin
  if (length(folder_10x) != nrow(sheet) ||
    length(folder_hto) != nrow(sheet)) {
    stop("BCL pins match multiple bcl folders")
  }

  sheet[["10x_bcl"]] <- folder_10x
  sheet[["hto_bcl"]] <- folder_hto

  sheet[["10x_pin"]] <- NULL
  sheet[["hto_pin"]] <- NULL
  sheet
}

#' Create sample sheet
#'
#' @param i7 vector of strings containing 10x index set names
#' @param hto vector of strings containing HTO index names
#' @param version string, chemistry version
#' @param flowcell_id string, containing 10 digit flowcell id
#'
#' @return string containing sample sheet
#' @export
make_sample_sheet <- function(i7, hto = NULL, version, flowcell_id) {
  header <- switch(version,
    "RNA v3.1" = samplesheet_dualindex_header,
    "RNA v3.0" = samplesheet_singleindex_header
  )
  prefix <- switch(version,
    "RNA v3.1" = "SI-TT-",
    "RNA v3.0" = "SI-GA-"
  )

  if (version == "RNA v3.0") {
    indexes <- unlist(translate_index_10x_single[i7, ])
    ids <- paste0(prefix, rep(i7, 4L), "_", rep(1L:4L, each = length(i7)))

    i7_string <- paste("", ids, ids, indexes, flowcell_id,
      sep = ",", collapse = "\n"
    )

    if (!is.null(hto)) {
      indexes <- unlist(translate_index_hto[hto, 1L])
      ids <- hto
      hto_string <- paste("", ids, ids, indexes, flowcell_id,
        sep = ",", collapse = "\n"
      )
    } else {
      hto_string <- NULL
    }
  } else {
    index1 <- translate_index_10x_dual[i7, 1L]
    # Index 2 is the old reverse complemented sequence
    index2 <- translate_index_10x_dual[i7, 3L]
    ids <- paste0(prefix, i7)

    i7_string <- paste("", ids, ids, index1, index2, flowcell_id, "",
      sep = ",", collapse = "\n"
    )

    if (!is.null(hto)) {
      index1 <- translate_index_hto[hto, 1L]
      index2 <- translate_index_hto[hto, 2L]
      ids <- hto

      hto_string <- paste("", ids, ids, index1, index2, flowcell_id, "",
        sep = ",", collapse = "\n"
      )
    } else {
      hto_string <- NULL
    }
  }

  out <- paste(header, i7_string, hto_string, sep = "\n")
  out
}

#' Infer config parameters and sanity check them
#'
#' @param config list of config settings
#' @param sheet data.frame generated by \link{read_input_files}
#' @param chemistry string, chemistry version
#'
#' @return list of updated config settings
#' @export
infer_and_check_config <- function(config, sheet, chemistry) {
  # Update the config, make warnings and errors as appropriate.
  inferred_parameters <- list(
    seq_type  = unique(sheet[["seq_type"]]),
    workflow  = unique(sheet[["workflow"]]),
    organism  = unique(sheet[["species"]]),
    n_samples = unique(sheet[["n_samples"]]),
    chemistry = unique(unlist(chemistry))
  )
  message <- c(
    seq_type  = "Mixture of whole cells and nuclei in sample sheet",
    workflow  = "Mixture of 10x and 10x + HTO in sample sheet",
    organism  = "Multiple species in sample sheets",
    n_samples = "Inconsistent number of samples detected",
    chemistry = "Mixture of 10x chemistries autodetected"
  )

  # Each parameter should be of length 1, e.g. only a single species.
  # For an unset (and thus inferred) parameter, it is an error otherwise.
  # For a manually set parameter it is a warning.
  for (var in names(inferred_parameters)) {
    inferred_value <- inferred_parameters[[var]]
    if (!(var %in% names(config))) {
      if (length(inferred_value) > 1L) {
        stop(message[var])
      } else {
        config[[var]] <- inferred_value
      }
    } else if (length(inferred_value) > 1L) {
      warning(message[var])
    }
  }

  config
}

#' Generate HTO feature tables
#'
#' @param sheet data.frame generated by \link{read_input_files}
#'
#' @return list of data.frames
#' @export
hto_features <- function(sheet) {
  all_samples <- sheet[, c("sample", "hash_index", "hto")]
  all_samples[["sequence"]] <-
    translate_bc_hto[all_samples[["hto"]], "Sequence"]
  idx <- all_samples[["hash_index"]]
  all_samples[["hash_index"]] <- NULL
  all_samples[["hto"]] <- NULL
  out <- split(all_samples, idx)

  out
}

#' Prepare for COMUNEQAID pipeline
#'
#' @param comuneqaid_id required string, project ID
#' @param input_files required vector of input file names usually xlsx file,
#' see details.
#' @param config list of user defined config settings, can be empty list.
#' If set, overrides all other settings including paths and comuneqaid id
#' given to this function.
#' @param lib_sheet_path optional string, path to library sheets folder
#' @param qc_path optional string, path to qc output folder
#' @param bcl_path optional string, path to bcl input folder
#' @param fastq_path optional string, path to fastq output folder
#' @param out_path optional string, path to results output folder
#' @param log_path optional string, path to logs output folder
#' @param config_path optional string, path to config file output folder
#'
#' @details Input files can be either xlsx file(s) or text-files from the
#' COMUNEQAID app. Using multiple xlsx files is untested and may break in new
#' and exciting ways.
#'
#' @return invisibly returns updated config list
#' @export
prepare_comuneqaid <- function(comuneqaid_id,
                               input_files,
                               config = list(),
                               lib_sheet_path = default_lib_sheet_path,
                               qc_path = default_qc_path,
                               bcl_path = default_bcl_path,
                               fastq_path = default_fastq_path,
                               out_path = default_out_path,
                               log_path = default_log_path,
                               config_path = default_config_path
                               ) {
  if (missing(comuneqaid_id)) {
    stop("comuneqaid_id must be specified")
  }
  if (length(comuneqaid_id) > 1) {
    stop("only one comuneqaid_id may be specified")
  }
  if (missing(input_files)) {
    stop("input_files(s) must be specified")
  }

  # Add missing variables to config
  # Names are the names of the variables, and values are the names in the config
  config_vars <- c(
    "comuneqaid_id"  = "comID",
    "lib_sheet_path" = "lib_sheet_path",
    "qc_path"        = "qc_path",
    "bcl_path"       = "bcl_path",
    "fastq_path"     = "fastq_path",
    "out_path"       = "out_path",
    "log_path"       = "log_path",
    "config_path"    = "config_path"
  )
  for (i in names(config_vars)) {
    if (!(config_vars[i] %in% names(config))) {
      config[[config_vars[i]]] <- get(i)
    } else {
      assign(i, config[[i]])
    }
  }

  # Handles multiple versions of sample-sheets and app files.
  sheet <- read_input_files(
    files = input_files,
    lib_sheet_path = lib_sheet_path
  )

  # We need to convert pins to bcl folders if we read comuneqaid-app input
  if (unique(tools::file_ext(input_files)) == "csv") {
    sheet <- from_pin_to_bcl(sheet, bcl_path)
  }

  bcl_folders <- c(sheet[["hto_bcl"]], sheet[["10x_bcl"]])
  bcl_folders <- unique(stats::na.omit(bcl_folders))

  prepare_folders(
    comuneqaid_id = comuneqaid_id,
    qc_path = qc_path,
    bcl_folders = bcl_folders,
    bcl_path = bcl_path,
    fastq_path = fastq_path,
    out_path = out_path,
    log_path = log_path,
    config_path = config_path
  )

  # Some parameters need to be inferred and sanity checked, e.g. check for
  # multiple organisms
  chemistry <- lapply(
    here::here(bcl_path, bcl_folders),
    detect_chemistry
  )

  config <- infer_and_check_config(config, sheet, chemistry)

  # SCOP ID is not used but kept only for reference
  config[["scop_id"]] <- unique(sheet[["scop_id"]])

  # PIN dictionary, directly from sheet
  config[["pin_10x"]] <- tapply(
    sheet[["i7_index"]],
    sheet[["10x_bcl"]],
    unique
  )

  if (config[["workflow"]] == "Y") {
    config[["pin_hto"]] <- tapply(
      sheet[["hash_index"]],
      sheet[["hto_bcl"]],
      unique
    )
  }

  # Create pool table
  pool_table <- make_pool_table(sheet, split_by = c("i7_index", "lane"))
  utils::write.csv(pool_table,
    file = here::here(log_path, comuneqaid_id, "poolTable.csv"),
    row.names = FALSE
  )

  # Write sample sheets:
  for (i in bcl_folders) {
    flowcell_id <- extract_flowcell_id(i)
    if (config[["workflow"]] == "Y") {
      hto <- config[["pin_hto"]][[i]]
    } else {
      hto <- NULL
    }
    sample_sheet <- make_sample_sheet(
      i7 = config[["pin_10x"]][[i]],
      hto = hto,
      version = config[["chemistry"]],
      flowcell_id = flowcell_id
    )
    sheet_name <- paste0("SampleSheet_", i, ".csv")
    writeLines(text = sample_sheet, con = here::here(fastq_path, sheet_name))
  }

  # Create feature tsv's
  if (config[["workflow"]] == "Y") {
    features <- hto_features(sheet)
    for (i in names(features)) {
      outfile <- here::here(out_path, comuneqaid_id, "hto", i, "features.tsv")
      dir.create(
        path = dirname(outfile),
        showWarnings = FALSE,
        recursive = TRUE
      )
      utils::write.table(x = features[[i]],
                         file = outfile,
                         row.names = FALSE,
                         col.names = FALSE,
                         sep = "\t",
                         quote = FALSE)
    }
  }

  # Workflow setting is changed to be more descriptive
  config[["workflow"]] <- ifelse(config[["workflow"]] == "Y",
    "10x + HTO",
    "10x"
  )

  config_file <- paste0(comuneqaid_id, "_config.yaml")
  yaml::write_yaml(config, file = here::here(config_path, config_file))

  invisible(config)
}
